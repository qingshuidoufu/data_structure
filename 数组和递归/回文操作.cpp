//题目10：
//【程序片段题】回文专题十二（回文数组）
//题目ID：1144
//【问题描述】
//给出一个数组 A[1..n]，如果对于任意的 1 <= i <= n，都有 A[i] = A[n - i + 1]，那么数组 A就是回文数组。给定 A数组后，如果 A不是回文数组，你要用最好的操作次数把 A 数组变成回文数组，每次操作你可以选定 A 数组相邻的两个数，不妨假设被选定的两个相邻的数是 x 和 y ，那么你可以用 x + y带替代原来的 x 和 y，即把 x 和 y从 A 数组删掉，用 x + y 的和替代 x 和 y 的位置，每次操作之后 A 数组都会少一个数。计算最少需要多少次操作才能使得 A 数组变成回文数组？
//提示：1)首先，可以确定如果在原序列中a[i]已经等于a[n - i + 1]的话，那么这两个数都不用动。2)其次，在原序列中的a[i]如果不等于a[n - i + 1]，那么这个回文数组就不能成立，所以他们之中必有一个数要和他相邻的合起来，那么和谁合呢？既然前面都已经是不用动的，那么自然而然是和他后面的合（n - i + 1的那个就跟他前面的合），那么问题又来了：难道i和n - i + 1都要分别合吗，未必。大家先看一个例子：1 2 4 6 1，（过程为：12461->1661）这个例子就是先把一个合起来。3)还有一个要注意的，两个之中合哪一个？显而易见，就是小的那个先合，因为a[i]是正整数，所以后面不可能变小。
//
//【输入形式】
//第一行，一个整数 n，表示数组有 n 个数构成。1 <= n <= 1000000。
//第二行，n个整数，第 i个整数是 A[i]， 1 <= A[i] <= 10 ^ 9。
//【输出形式】一个整数，表示最少的操作次数。如果不能构成回文数组，则输出 - 1。
//【测试用例】
//1）
//输入：
//7
//33 11 34 48 30 21 75
//输出：
//5
//2）
//输入：
//9
//10 20 30 40 50 50 60 50 90
//输出：
//7
//3）
//输入：
//10
//1 1 1 1 1 1 1 1 1 10
//输出：
//- 1
//4）
//输入：
//9
//1 1 1 1 1 1 1 1 1
//输出：
//0
//5）
//输入：
//10
//10 20 30 40 50 50 100 60 50 90
//输出：
//0

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define Maxn 10001
int main()
{
	int flag = 0;
	int i, n, a[Maxn], left, right, ans = 0;
	scanf("%d", &n);
	for (i = 1; i <= n; i++) scanf("%d", &a[i]);
	left = 1; right = n;
	while (left < right)
	{
		if (a[left] == a[right])
		{
			if (left + 1 == right || left + 2 == right) {//成功得到回文数组 
				flag = 1;


			}
			left++; right--;//left和right指针的移动 
		}
		else if (a[left] > a[right]) //右部做操作 
		{
			a[right - 1] += a[right];
			right--;
			ans++;
		}
		else//左部做操作 
		{

			a[left + 1] += a[left];
			left++;
			ans++;

		}
	}
	if (flag == 0) ans = -1;
	printf("%d\n", ans);
	return 0;
}