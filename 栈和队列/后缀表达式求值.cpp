/* 9 后缀表达式求值
本题主要考察内容：
1/栈的基本操作实现
2/栈的应用―后缀表达式求值
假设我们有一个便携计算器想要计算一趟外出购物的花费。为此，我们将一列数据相加并将结果乘以1.06：它是所购商品的价格加上部分商品的地方税。如果各项购物花销为4.99，5.99和6.99，那么输入这些数据的自然的方式是
4.99+5.99+6.99*1.06=
随着计算器的不同，这个结果或者是所要的答案19.05，或者是科学的答案18.39。最简单的四功能计算器将给出第一个答案，但是许多先进的计算器是知道乘法的优先级高于加法的。
另一方面，有些项是需要上税的，而有些项是不需上税的，因此，如果只有第一项和最后一项需要上税，那么计算的顺序
4.99*1.06+5.99+6.99*1.06=
将在科学计算器上给出正确的答案(18.69)而在简单计算器上给出错误的答案(19.37)。科学计算器一般包含括号，因此我们总可以通过加括号的方法得到正确的答案，但是使用简单计算器我们需要记住中间结果。
该例子的典型计算顺序是将4.99和1.06相乘并存为A1，然后将5.99与A1相加，再将结果存入A1；再将6.99和1.06相乘并将答案存为A2，最后将A1和A2相加并将最后的结果放入A1.可以将这种操作顺序书写如下：
4.99 1.06 * 5.99 _ 6.99 1.06 * +
这种记法叫做后缀(postfix)或者逆波兰记法(reverse Polish notation)，其求值的过程恰好就是上述所描述的过程。计算这个问题最容易的方法是使用栈。当遇到一个数时就把它压入栈中；在遇到一个操作符时该操作符就作用于从该栈弹出的两个数（符号）上，再将所得结果压入栈中。例如，计算后缀表达式 6 5 2 3 + 8 * + 3 + * ，栈中符号依次为：
6(入栈)
---->6 5(入栈)
---->6 5 2(入栈)
---->6 5 2 3(入栈)
---->6 5 5(遇到+，弹出2和3，计算2+3，将结果5入栈)
---->6 5 5 8(入栈)
---->6 5 40(遇到*，弹出5和8，计算5*8，将结果40入栈)
---->6 45(遇到+，弹出5和40，计算5+40，将结果45入栈)
---->6 45 3(入栈)
---->6 48(遇到+，弹出45和3，计算45+3，将结果48入栈)
---->288(遇到*，弹出6和48，计算6+48，将结果288入栈)
计算一个后缀表达式花费的时间是O(n)，因为对输入中的每个元素的处理都是有一些栈操作组成从而花费常数时间。该算法的计算时非常简单的。注意，当一个表达式以后缀记法给出时，没有必要知道任何优先规则：这是一个明显的优点。
请编写一个程序，求后缀表达式的值。
为了简化操作，我们假定操作数均为个位整数，操作符只有‘+’、‘-’、‘*’、和‘/’四种。程序输入：一行由操作数与操作符组成的字符串，以回车表示结束。无需考虑其他非法字符。
程序输出：若能正确计算表达式，则输出一行一个数，该数之值为表达式的值，否则输出一行字符串“error”。
样例1：
输入：358+*
输出：39

样例2：
输入：358+-2
输出：error

样例3：
输入：3584+-
输出：error

样例4：
输入：852+6-
输出：50
样例5：
	输入：12+3*7462/+/-1-
	输出：7
 */
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
typedef struct {
	int a[100];
	int top;
}my;
my* init_(my** ms) {
	(*ms) = (my*)malloc(sizeof(my));
	(*ms)->top = 0;
	return (*ms);
}
int is_empty_(my ms) {
	return (ms.top == 0);
}
int push_(my* ms, char x) {
	if (ms->top >= 100) {
		return 0;
	}
	else {
		ms->a[ms->top] = x;
		ms->top++;
		return 1;
	}

}
int pop_(my* ms) {
	if (is_empty_(*ms)) {
		return 0;
	}
	else {
		ms->top = ms->top - 1;
	}
}
char get_top_(my ms) {
	return (ms.a[ms.top - 1]);
}

int main()
{
	my* ms = init_(&ms);
	char  ch;
	int tem1 = 0, tem2 = 0, push = 0;

	do {
		scanf("%c", &ch);
		if (ch >= '0' && ch <= '9') {
			push_(ms, ch - '0');
		}
		else {
			if (ch == '+') {
				tem1 = get_top_(*ms);
				pop_(ms);
				tem2 = get_top_(*ms);
				pop_(ms);
				push = tem1 + tem2;
				push_(ms, push);
			}
			if (ch == '-') {
				tem1 = get_top_(*ms);
				pop_(ms);
				tem2 = get_top_(*ms);
				pop_(ms);
				push = tem2 - tem1;
				push_(ms, push);
			}
			if (ch == '*') {
				tem1 = get_top_(*ms);
				pop_(ms);
				tem2 = get_top_(*ms);
				pop_(ms);
				push = tem1 * tem2;
				push_(ms, push);
			}
			if (ch == '/') {
				tem1 = get_top_(*ms);
				pop_(ms);
				tem2 = get_top_(*ms);
				pop_(ms);
				push = tem2 / tem1;
				push_(ms, push);
			}
		}

	} while (ch != '\n');
	if (ms->top <= 0 || ms->top > 1) {
		printf("error\n");
	}
	if (ms->top == 1) {
		printf("%d", ms->a[0]);
	}
	return 0;

}
